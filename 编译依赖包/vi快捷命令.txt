显示行号
:set number

跳转到制定行数
输入 行号 + G，例如跳转到第 42 行：
42G

搜索指定内容
1. 向前搜索（从当前光标向文件末尾查找）
按 / 键（进入搜索模式）
输入要查找的内容（例如 error）
按 Enter
/error
2. 向后搜索（从当前光标向文件开头查找）
按 ? 键
输入内容，按 Enter
?error
 3.跳转到下一个/上一个匹配项
快捷键	作用
n	跳转到下一个匹配项（方向与上次搜索一致）
N	跳转到上一个匹配项


保存退出
:wq

删除 (Cut/Delete)
x：删除光标所在的一个字符。
dd：删除（剪切）整行。
ndd：删除向下 n 行（例如 5dd 删除 5 行）。
dw：删除一个单词。
复制 (Copy/Yank)
yy：复制整行。
nyy：复制向下 n 行（例如 5yy 复制 5 行）。
yw：复制一个单词。
选中复制：按 v 进入可视模式，移动光标选中内容，然后按 y 复制。
粘贴 (Paste)
p：在光标之后粘贴。
P (大写)：在光标之前粘贴。
撤销 (Undo)
u：撤销上一步操作（如果你误删了，按这个）。





由于 Buildroot 的机制是 “先解压源码，再编译”，所以这些文件在刚开始解压 SDK 时是不存在的。

需要采用 “遇到报错 -> 执行对应修复指令 -> 继续编译” 的策略。

这里整理好了你需要的 Sed 一键修复指令。

这些指令分为两组：一组针对 Recovery（rockchip_rk356x_recovery），一组针对 主系统（rockchip_rk3568）。

请注意：必须等到编译报错（源码解压出来后）再执行对应的指令，否则会提示“文件不存在”。

一、 修复 host-m4 (SIGSTKSZ 问题)
2025-12-31T21:26:53 >>> host-m4 1.4.18 Building
报错特征：c-stack.c:55:26: error: missing binary operator before token "("

1. 针对 Recovery 目录
# 替换 c-stack.c 中的代码块
sed -i '/^#ifndef SIGSTKSZ/,/^#endif/c\/* 修复 host-m4 在新版 glibc 编译报错的问题 */\n#ifdef SIGSTKSZ\n# undef SIGSTKSZ\n#endif\n#define SIGSTKSZ 16384' \
buildroot/output/rockchip_rk356x_recovery/build/host-m4-1.4.18/lib/c-stack.c
./build.sh recovery

2. 针对 Buildroot 主系统目录
# 替换 c-stack.c 中的代码块
sed -i '/^#ifndef SIGSTKSZ/,/^#endif/c\/* 修复 host-m4 在新版 glibc 编译报错的问题 */\n#ifdef SIGSTKSZ\n# undef SIGSTKSZ\n#endif\n#define SIGSTKSZ 16384' \
buildroot/output/rockchip_rk3568/build/host-m4-1.4.18/lib/c-stack.c
./build.sh buildroot

二、 修复 host-fakeroot (_STAT_VER 问题)
2025-12-31T22:05:15 >>> host-fakeroot 1.20.2 Building
注意：如果你已经按照之前的建议修改了 package/fakeroot/fakeroot.mk 升级到了 1.32.1，则不需要执行此步骤。如果你还在用旧版 1.20.2，则执行以下指令。

报错特征：_STAT_VER 未定义。

1. 针对 Recovery 目录
# 在 #include <sys/types.h> 后面插入修复补丁
sed -i '/#include <sys\/types.h>/a \/* --- FIX START --- *\/\n#include <sys\/stat.h>\n#ifndef _STAT_VER\n #if defined (__aarch64__)\n  #define _STAT_VER 0\n #elif defined (__x86_64__)\n  #define _STAT_VER 1\n #else\n  #define _STAT_VER 3\n #endif\n#endif\n\/* --- FIX END --- *\/' \
buildroot/output/rockchip_rk356x_recovery/build/host-fakeroot-1.20.2/libfakeroot.c
./build.sh recovery

2. 针对 Buildroot 主系统目录
# 在 #include <sys/types.h> 后面插入修复补丁
sed -i '/#include <sys\/types.h>/a \/* --- FIX START --- *\/\n#include <sys\/stat.h>\n#ifndef _STAT_VER\n #if defined (__aarch64__)\n  #define _STAT_VER 0\n #elif defined (__x86_64__)\n  #define _STAT_VER 1\n #else\n  #define _STAT_VER 3\n #endif\n#endif\n\/* --- FIX END --- *\/' \
buildroot/output/rockchip_rk3568/build/host-fakeroot-1.20.2/libfakeroot.c
./build.sh buildroot

三、 修复 Makefile/host-squashfs (fcommon & sysmacros 问题)
2026-01-01T01:38:39 >>> host-squashfs 3de1687d7432ea9b302c2db9521996f506c140a3 Building
报错特征：multiple definition 或 sys/types.h 相关错误。
这里我们只修改头文件和Makefile，不需要改那十几个 .c 文件，效果是一样的。

1. 针对 Recovery 目录
# 1. 在头文件 squashfs_fs.h 第一行插入 sysmacros.h
sed -i '1i#include <sys/sysmacros.h>' \
buildroot/output/rockchip_rk356x_recovery/build/host-squashfs-*/squashfs-tools/squashfs_fs.h
# 2. 在 Makefile 中添加 -fcommon
sed -i 's/CFLAGS ?= -O2/CFLAGS ?= -O2 -fcommon/' \
buildroot/output/rockchip_rk356x_recovery/build/host-squashfs-*/squashfs-tools/Makefile
# 3. 清理旧对象文件（防止链接错误）
rm -f buildroot/output/rockchip_rk356x_recovery/build/host-squashfs-*/squashfs-tools/*.o
./build.sh recovery

2. 针对 Buildroot 主系统目录
# 1. 在头文件 squashfs_fs.h 第一行插入 sysmacros.h
sed -i '1i#include <sys/sysmacros.h>' \
buildroot/output/rockchip_rk3568/build/host-squashfs-*/squashfs-tools/squashfs_fs.h
# 2. 在 Makefile 中添加 -fcommon
sed -i 's/CFLAGS ?= -O2/CFLAGS ?= -O2 -fcommon/' \
buildroot/output/rockchip_rk3568/build/host-squashfs-*/squashfs-tools/Makefile
# 3. 清理旧对象文件
rm -f buildroot/output/rockchip_rk3568/build/host-squashfs-*/squashfs-tools/*.o
./build.sh buildroot

总结：你的编译流程
运行 ./build.sh recovery
遇到 m4 报错 -> 运行 一.1 的指令 -> 继续编译
遇到 squashfs 报错 -> 运行 三.1 的指令 -> 继续编译
(如果 fakeroot 没升级) 遇到 fakeroot 报错 -> 运行 二.1 的指令 -> 继续编译

运行 ./build.sh buildroot (编译主系统)
遇到 m4 报错 -> 运行 一.2 的指令 -> 继续编译
遇到 squashfs 报错 -> 运行 三.2 的指令 -> 继续编译
(如果 fakeroot 没升级) 遇到 fakeroot 报错 -> 运行 二.2 的指令 -> 继续编译



完整的解决流程（会踩坑）
问题一：
2025-12-31T21:26:53 >>> host-m4 1.4.18 Building
Done in 43s  (error code: 2)
Command exited with non-zero status 2
you take 0:42.65 to build recovery
ERROR: Running build_recovery failed!
ERROR: exit code 2 from line 563:
/usr/bin/time -f "you take %E to build recovery" $COMMON_DIR/mk-ramdisk.sh recovery.img $RK_CFG_RECOVERY

这是一个非常典型的 Glibc 版本不兼容 问题。
找到报错的源文件：
根据你的日志路径，文件应该位于：
/home/wzp/BSP/rk356x_linux/buildroot/output/rockchip_rk356x_recovery/build/host-m4-1.4.18/lib/c-stack.c
问题原因：
请看你文件中的 第 132 行：
char buffer[SIGSTKSZ];
这里的 SIGSTKSZ 用来定义一个静态联合体（union）中数组的大小。在以前的 Linux 系统中，SIGSTKSZ 是一个常数（通常是 8192）。但在较新的 Ubuntu（如 22.04+）中，SIGSTKSZ 变成了一个运行时变量（sysconf 调用），导致编译器报错：“无法在文件作用域使用变长数组”。

解决方法：
#ifndef SIGSTKSZ
# define SIGSTKSZ 16384
#elif HAVE_LIBSIGSEGV && SIGSTKSZ < 16384
/* libsigsegv 2.6 through 2.8 have a bug where some architectures use
   more than the Linux default of an 8k alternate stack when deciding
   if a fault was caused by stack overflow.  */
# undef SIGSTKSZ
# define SIGSTKSZ 16384
#endif

改成：

#if ! HAVE_STACK_T && ! defined stack_t
typedef struct sigaltstack stack_t;
#endif

/* 修复 host-m4 在新版 glibc 编译报错的问题 */
#ifdef SIGSTKSZ
# undef SIGSTKSZ
#endif
#define SIGSTKSZ 16384

#include <stdlib.h>
#include <string.h>

4. 保存并重新编译
保存文件后，回到终端，直接再次运行编译命令即可（不需要 clean，直接继续编译）：
./build.sh recovery


问题二：
2025-12-31T22:05:15 >>> host-fakeroot 1.20.2 Building
Done in 14min 34s  (error code: 2)
Command exited with non-zero status 2
you take 14:34.59 to build recovery
ERROR: Running build_recovery failed!
ERROR: exit code 2 from line 563:
/usr/bin/time -f "you take %E to build recovery" $COMMON_DIR/mk-ramdisk.sh recovery.img $RK_CFG_RECOVERY


问题在于Ubuntu 系统（Host）使用了较新的 Glibc 库，而这个老版本的 fakeroot 源码依赖于一个已经被 Glibc 移除的宏 _STAT_VER。
你需要修改这个文件，在 第 124 行 左右的位置插入一段补丁代码。
修改步骤
1. 打开文件
文件路径（根据你之前的日志）：
/home/wzp/BSP/rk356x_linux/buildroot/output/rockchip_rk356x_recovery/build/host-fakeroot-1.20.2/libfakeroot.c
2. 找到定位点
请找到 第 124 行 左右的 #include <sys/types.h>。
原文内容（大约 120-126 行）：

#include <unistd.h>
#include <dirent.h>
#include <errno.h>
#include <sys/types.h>
#ifdef HAVE_SYS_ACL_H
#include <sys/acl.h>

改成：

#include <unistd.h>
#include <dirent.h>
#include <errno.h>
#include <sys/types.h>

/* --- FIX START: 修复新版 Ubuntu/Glibc 编译报错 --- */
#include <sys/stat.h>
#ifndef _STAT_VER
 #if defined (__aarch64__)
  #define _STAT_VER 0
 #elif defined (__x86_64__)
  #define _STAT_VER 1
 #else
  #define _STAT_VER 3
 #endif
#endif
/* --- FIX END --- */

#ifdef HAVE_SYS_ACL_H
#include <sys/acl.h>
#endif /* HAVE_SYS_ACL_H */
5. 保存并继续编译
保存文件后，不需要执行 clean 操作，直接回到终端运行编译命令即可，它会接着刚才的地方继续编译：

./build.sh recovery


问题三：
2026-01-01T01:38:39 >>> host-squashfs 3de1687d7432ea9b302c2db9521996f506c140a3 Building
Done in 37s  (error code: 2)
Command exited with non-zero status 2
you take 0:37.52 to build recovery
ERROR: Running build_recovery failed!
ERROR: exit code 2 from line 563:
/usr/bin/time -f "you take %E to build recovery" $COMMON_DIR/mk-ramdisk.sh recovery.img $RK_CFG_RECOVERY


cd /home/wzp/BSP/rk356x_linux/buildroot/output/rockchip_rk356x_recovery/build/host-squashfs-3de1687d7432ea9b302c2db9521996f506c140a3/squashfs-tools

Makefile里
CFLAGS ?= -O2
CFLAGS += $(EXTRA_CFLAGS) $(INCLUDEDIR) -D_FILE_OFFSET_BITS=64 \
	-D_LARGEFILE_SOURCE -D_GNU_SOURCE -DCOMP_DEFAULT=\"$(COMP_DEFAULT)\" \
	-Wall
将其修改为（添加了一行 CFLAGS += -fcommon）：

CFLAGS ?= -O2
CFLAGS += -fcommon
CFLAGS += $(EXTRA_CFLAGS) $(INCLUDEDIR) -D_FILE_OFFSET_BITS=64 \
	-D_LARGEFILE_SOURCE -D_GNU_SOURCE -DCOMP_DEFAULT=\"$(COMP_DEFAULT)\" \
	-Wall

mksquashfs.c/unsquashfs.c/acton.c/info.c/process_fragments.c/persudo.c/read_.c/resore.c/sort.c/mksquashfs_info.c/xattr.c：在 #include <sys/types.h> 后添加 #include <sys/sysmacros.h>


或者. 进入源码目录
cd /home/wzp/BSP/rk356x_linux/buildroot/output/rockchip_rk356x_recovery/build/host-squashfs-3de1687d7432ea9b302c2db9521996f506c140a3/squashfs-tools
2. 核心修复：修改 squashfs_fs.h
我们在该文件开头插入 #include <sys/sysmacros.h>，这样所有源文件都能生效。
# 使用 sed 命令一键插入（比手动打开编辑器更稳）
sed -i '1i#include <sys/sysmacros.h>' squashfs_fs.h

之前改过，但为了确保万无一失，请检查或再次执行：
# 找到 CFLAGS 并追加 -fcommon
sed -i 's/CFLAGS ?= -O2/CFLAGS ?= -O2 -fcommon/' Makefile
(或者可以像之前一样手动打开 Makefile 确认 CFLAGS 里有 -fcommon)
4. 关键步骤：清理旧的编译中间文件
因为之前改了很多文件又失败了，可能残留了一些错误的 .o 目标文件。我们需要把它们删掉，触发重新编译（但不要删源码目录）。
# 删除所有编译生成的 .o 文件和可执行文件
rm -f *.o mksquashfs unsquashfs


问题一到三可在快捷键txt中快速解决